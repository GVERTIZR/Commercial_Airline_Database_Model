--1
CREATE TRIGGER date_restrict_trigger 
ON flights
AFTER INSERT, UPDATE --specify that the trigger fires after an insert or update operation.
AS
BEGIN
    IF EXISTS (SELECT 1 FROM inserted WHERE date < '2016-01-01' OR date > '2019-12-31') --Inside the trigger body, an IF statement checks if any inserted or updated rows have a date value before 2016 or after 2019.
    BEGIN
        RAISERROR ('Date must be between 2016 and 2019.', 16, 1);
        ROLLBACK TRANSACTION;
    END
END;

--2
CREATE TRIGGER trigger_planes 
ON planes
INSTEAD OF INSERT, UPDATE, DELETE
AS
	BEGIN 
	SET NOCOUNT ON
	RAISERROR('Input, modification or deletion of rows not allowed',16,1); --instead of inserting deleting or updating an error will be raised
	END;

--3
-- Creating a trigger named RestrictTicketPriceUpdate
CREATE TRIGGER RestrictTicketPriceUpdate 
ON tickets 
INSTEAD OF UPDATE 
AS
BEGIN 
    -- Check if there's an update on the final_price column 
    IF UPDATE(final_price) 
    BEGIN 
        -- Check if the updated final_price meets the criteria 
        IF EXISTS ( 
            SELECT 1 
            FROM inserted i -- Newly inserted rows
            JOIN deleted d ON i.ticket_id = d.ticket_id -- Deleted rows
            JOIN routes_cabin_types rct ON route_id = rct.route_id AND i.cabin_type_id = rct.cabin_type_id -- Joining routes_cabin_types table
            WHERE ABS(i.final_price - rct.price) > (rct.price * 0.2) -- Checking if the updated final_price is more than 20% different from the corresponding price in routes_cabin_types table
        ) 
        BEGIN 
            -- Raise an error if the condition is met
            RAISERROR('The updated final_price must be within 20%% of the corresponding price in routes_cabin_types table.', 16, 1); 
            ROLLBACK TRANSACTION; -- Rollback the transaction
            RETURN; -- Exit the trigger
        END 
        ELSE 
        BEGIN 
            -- Allow the update if the condition is not met
            UPDATE tickets 
            SET final_price = i.final_price -- Update the final_price column
            FROM inserted i 
            WHERE tickets.ticket_id = i.ticket_id; -- Matching ticket IDs
        END 
    END 
END;

--4
CREATE TRIGGER First_Name_Length
ON Customers
INSTEAD OF INSERT, UPDATE
AS
BEGIN
    DECLARE @MinLength INT, @MaxLength INT; --We declare this variables to store minimum and maximum lengths of first names
   
    SELECT @MinLength = MIN(LEN(first_name)), @MaxLength = MAX(LEN(first_name)) --This will get the minimum and maximum length of existing first_name values
    FROM Customers;


    IF EXISTS (
        SELECT 1
        FROM inserted as i
        WHERE LEN(i.first_name) < @MinLength
            OR LEN(i.first_name) > @MaxLength
    ) --This if statement will check if any new/updated first_name values violete the length restrictions
    BEGIN
        RAISERROR('Length violates restrictions.', 16, 1); --This Will raise an error if the length of any new/update first_name violates restrictions
        ROLLBACK TRANSACTION; --The transaction will rollback if the condition is met
    END;
END;

--5
create table tb_audit
(
aud_id                     	int identity,        --autogenerated identifier
aud_station              	varchar(50), 	--name of the computer from which the operation was done
aud_operation          	varchar(50), 	--type of operation: INSERT, UPDATE or DELETE
aud_date                  	date,             	--date of the operation
aud_time                  	time,            	--time of the operation
aud_username          	varchar(50), 	--SQL Server login name used for the operation
aud_table                 	varchar(50), 	--table in which the operation was performed
aud_identifier_id      	varchar(50), 	--value of the id of the tuple affected by the operation
aud_column             	varchar(50), 	--name of the column affected by the operation
aud_before               	varchar(max),   --value of the column before the operation
aud_after                  	varchar(max)	--value of the column after the operation
)


Create trigger tr_planes ON planes
AFTER insert, update, delete as
Set nocount on
Begin
	If exists (select * from inserted) and not exists ( select * from deleted)
	Begin
		Print 'INSERT'


Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'plane_id', NULL, plane_id from inserted
Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'fabrication_date', NULL, fabrication_date from inserted
Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT',GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'first_use_date', NULL, first_use_date from inserted
Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT',GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'first_use_date', NULL, first_use_date from inserted
Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT',GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'brand', NULL, brand from inserted
Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT',GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'model', NULL, model from inserted
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT',GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'capacity', NULL, capacity from inserted
END
ELSE IF exists (select * from inserted) and exists (select * from deleted)
BEGIN
	Print 'UPDATE'
Declare @temporalinserted table(


plane_id       int,
fabrication_date   date,
first_use_date       date,
brand            varchar(50),
model           varchar(50),
capacity      int)


Declare @temporaldeleted table(


plane_id       int,
fabrication_date   date,
first_use_date       date,
brand            varchar(50),
model           varchar(50),
capacity      int)
INSERT INTO @temporalinserted (plane_id, fabrication_date, first_use_date, brand, model, capacity)
SELECT  plane_id, fabrication_date, first_use_date, brand, model, capacity from inserted
INSERT INTO @temporaldeleted (plane_id, fabrication_date, first_use_date, brand, model, capacity)
SELECT  plane_id, fabrication_date, first_use_date, brand, model, capacity from deleted


Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', ti.plane_id, 'plane_id', td.plane_id, ti.plane_id
FROM @temporalinserted ti JOIN @temporaldeleted td ON ti.plane_id=td.plane_id
WHERE td.plane_id<>ti.plane_id  --to change plane_id


Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', ti.plane_id, 'fabrication_date', td.fabrication_date, ti.fabrication_date
FROM @temporalinserted ti JOIN @temporaldeleted td ON ti.plane_id=td.plane_id
WHERE td.fabrication_date <>ti.fabrication_date


Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', ti.plane_id, 'first_use_date', td.first_use_date, ti.first_use_date
FROM @temporalinserted ti JOIN @temporaldeleted td ON ti.plane_id=td.plane_id
WHERE td.first_use_date <>ti.first_use_date
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', ti.plane_id, 'brand', td.brand, ti.brand
FROM @temporalinserted ti JOIN @temporaldeleted td ON ti.plane_id=td.plane_id
WHERE td.brand <>ti.brand
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', ti.plane_id, 'model', td.model, ti.model 
FROM @temporalinserted ti JOIN @temporaldeleted td ON ti.plane_id=td.plane_id
WHERE td.model <>ti.model
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', ti.plane_id, 'capacity', td.capacity, ti.capacity 
FROM @temporalinserted ti JOIN @temporaldeleted td ON ti.plane_id=td.plane_id
WHERE td.capacity <>ti.capacity






END


ELSE IF not exists (select * from inserted) and exists (select * from deleted)
BEGIN
	Print 'DELETE'
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'plane_id',  plane_id , NULL from inserted
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'fabrication_date',  fabrication_date , NULL from inserted
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'first_use_date',  first_use_date , NULL from inserted
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'brand',  brand , NULL from inserted
Insert into tb_audit(aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'model',  model , NULL from inserted
Insert into tb_audit (aud_station, aud_operation, aud_date, aud_time, aud_username, aud_table, aud_identifier_id, aud_column, aud_before, aud_after)
SELECT HOST_NAME(),'INSERT', GETDATE(),GETDATE(),SYSTEM_USER, 'planes', plane_id, 'capacity',  capacity , NULL from inserted
END
END
;
--6
CREATE VIEW top_100_customers AS
SELECT TOP 100
    c.customer_id,
    c.first_name,
    c.last_name,
    c.birth_date,
    DATEDIFF(YEAR, c.birth_date, GETDATE())- --DATEDIFF function to calculate the difference in years between the birth_date and the current date (GETDATE()).
    CASE
        WHEN DATEADD(YY, DATEDIFF(YEAR, c.birth_date, GETDATE()), c.birth_date) > GETDATE() THEN 1
        ELSE 0
    END AS current_age,
    cs.name AS city_name --We adjust the age based on whether the current date has passed the birthday of the customer in the current year
FROM
    customers c
JOIN
    cities_states cs ON c.city_state_id = cs.city_state_id --We join the customers and cities_states tables on the city_state_id column to get the city name associated with each customer
ORDER BY
    current_age ASC,
    c.birth_date DESC;

	--7 
	
	CREATE VIEW Top3RoutesPerWeekday_2 AS
	WITH RankedRoutes AS (
    SELECT
        COUNT(c.customer_id) AS number_of_customers, -- count customers that were on a flight
        r.route_id AS route,
        c1.name AS origin_city,
        c2.name AS destination_city,
        w.weekday_id,
        w.name AS week_day,
        ROW_NUMBER() OVER(PARTITION BY w.weekday_id ORDER BY COUNT(c.customer_id) DESC) AS route_rank --This will subdivide into each weekday to retrieve the top 3 from each 
    FROM
        routes r
        JOIN weekdays w ON r.weekday_id = w.weekday_id
        JOIN flights f ON r.route_id = f.route_id
        JOIN cities_states c1 ON r.city_state_id_origin = c1.city_state_id
        JOIN cities_states c2 ON r.city_state_id_destination = c2.city_state_id --to find the origin and destination
		JOIN tickets t ON t.flight_id=f.flight_id
		JOIN customers c ON c.customer_id=t.customer_id --join on customers to find how many of them flew 


       
    WHERE
        YEAR(f.date) = 2016 OR YEAR(f.date) = 2017 --filter those years
    GROUP BY
        w.weekday_id,
        w.name,
        r.route_id,
        c1.name,
        c2.name
	
)
SELECT
    number_of_customers,
    route,
    origin_city,
    destination_city,
    weekday_id,
    week_day
FROM
    RankedRoutes
WHERE
    route_rank <= 3 --retrieve top 3
	;
--8 
CREATE VIEW city_flight_summary AS


SELECT TOP(20) -- This will select the top 20 cities based on the total number of customers in each city
		cs.name AS city, cs.city_state_id, 
		COUNT(*) AS NumOfCustomers, --This will count the total number of customers in each city
		COUNT(CASE WHEN c.gender = 'M' then 1 end) AS MaleCustomer, --Count the number of male customers in each city
		COUNT(CASE WHEN c.gender = 'F' then 1 end) AS FemaleCustomers, --Count the number of female customers in each city
		COUNT(CASE WHEN YEAR(ti.boarding_date) = 2016 then 1 end) AS flights_2016, --Count the number of flights in 2016 for each city
		COUNT(CASE WHEN YEAR(ti.boarding_date) = 2017 then 1 end) AS flights_2017, --Count the number of flights in 2017 for each city
		COUNT(CASE WHEN YEAR(ti.boarding_date) = 2016 AND c.gender = 'M' then 1 end) as MaleFlights_2016, --Count the number of flights in 2016 for male customers in each city
		COUNT(CASE WHEN YEAR(ti.boarding_date) = 2017 AND c.gender = 'M' then 1 end) as Maleflights_2017, --Count the number of flights in 2016 for male customers in each city
		COUNT(CASE WHEN YEAR(ti.boarding_date) = 2016 AND c.gender = 'F' then 1 end) as FemaleFlights_2016, --Count the number of flights in 2016 for female customer in each city
		COUNT(CASE WHEN YEAR(ti.boarding_date) = 2017 AND c.gender = 'F' then 1 end) as Femaleflights_2017 --Count the number of flights in 2017 for female customer in each city
FROM	cities_states as cs JOIN 
		customers as c ON cs.city_state_id=c.city_state_id JOIN
		tickets as ti ON ti.customer_id = c.customer_id
WHERE YEAR(ti.boarding_date) = 2017 OR YEAR(ti.boarding_date) = 2016 --Will filter the data for the years 2016 and 2017
GROUP BY cs.name, cs.city_state_id --Will group results by city name and city_state_id
ORDER BY NumOfCustomers DESC --Order the results by the number of customers in descending order. 
;
--9
-- Creating a view named city_customer_flight_summary
CREATE VIEW city_customer_flight_summary AS


-- Selecting the top 3 cities based on the number of flights
SELECT TOP 3
    cs.name AS city_name, -- Selecting the city name
    -- Counting the number of customers aged 25 or younger
    COUNT(DISTINCT CASE
                    WHEN YEAR(GETDATE()) - YEAR(c.birth_date) - 
                         CASE WHEN DATEPART(DAYOFYEAR, c.birth_date) > DATEPART(DAYOFYEAR, GETDATE()) THEN 1 ELSE 0 END - 
                         YEAR(c.birth_date) % 5 <= 25 THEN c.customer_id 
                    ELSE NULL 
                   END) AS num_customers_25_or_younger,
    -- Counting the number of customers aged between 26 and 40
    COUNT(DISTINCT CASE
                    WHEN YEAR(GETDATE()) - YEAR(c.birth_date) - 
                         CASE WHEN DATEPART(DAYOFYEAR, c.birth_date) > DATEPART(DAYOFYEAR, GETDATE()) THEN 1 ELSE 0 END - 
                         YEAR(c.birth_date) % 5 BETWEEN 26 AND 40 THEN c.customer_id 
                    ELSE NULL 
                   END) AS num_customers_26_to_40,
    -- Counting the number of customers aged between 41 and 55
    COUNT(DISTINCT CASE
                    WHEN YEAR(GETDATE()) - YEAR(c.birth_date) - 
                         CASE WHEN DATEPART(DAYOFYEAR, c.birth_date) > DATEPART(DAYOFYEAR, GETDATE()) THEN 1 ELSE 0 END - 
                         YEAR(c.birth_date) % 5 BETWEEN 41 AND 55 THEN c.customer_id 
                    ELSE NULL 
                   END) AS num_customers_41_to_55,
    -- Counting the number of customers aged between 56 and 70
    COUNT(DISTINCT CASE
                    WHEN YEAR(GETDATE()) - YEAR(c.birth_date) - 
                         CASE WHEN DATEPART(DAYOFYEAR, c.birth_date) > DATEPART(DAYOFYEAR, GETDATE()) THEN 1 ELSE 0 END - 
                         YEAR(c.birth_date) % 5 BETWEEN 56 AND 70 THEN c.customer_id 
                    ELSE NULL 
                   END) AS num_customers_56_to_70,
    -- Counting the number of customers aged 71 or older
    COUNT(DISTINCT CASE
                    WHEN YEAR(GETDATE()) - YEAR(c.birth_date) - 
                         CASE WHEN DATEPART(DAYOFYEAR, c.birth_date) > DATEPART(DAYOFYEAR, GETDATE()) THEN 1 ELSE 0 END - 
                         YEAR(c.birth_date) % 5 > 70 THEN c.customer_id 
                    ELSE NULL 
                   END) AS num_customers_71_or_older,
    -- Counting the number of distinct flights
    COUNT(DISTINCT t.flight_id) AS num_flights
FROM 
    cities_states cs -- Joining cities_states table
JOIN 
    customers c ON cs.city_state_id = c.city_state_id -- Joining customers table
JOIN 
    tickets t ON c.customer_id = t.customer_id -- Joining tickets table
JOIN 
    flights f ON t.flight_id = f.flight_id -- Joining flights table
WHERE 
    YEAR(t.purchase_date) IN (2016, 2017) -- Filtering tickets purchased in 2016 or 2017
GROUP BY 
    cs.name -- Grouping by city name
ORDER BY 
    city_name, num_flights DESC; -- Ordering by city name and number of flights in descending order

--10
--EMPLOYEES (8) 
ALTER TABLE employees
ADD CONSTRAINT valid_bd CHECK (birth_date>'1900-04-19'),--employees can't be older than 114 years old
CONSTRAINT employee_age CHECK (DATEDIFF(YEAR,birth_date,hire_date)>=18), --at least 18 years old
CONSTRAINT gender_selection CHECK (gender IN ('F','M')), --only two possible values for gender (instead of creating a domain)
CONSTRAINT ssn_valid CHECK(LEN(ssn)=11), --valid ssn containing 9 digits and two dashes
CONSTRAINT ssn_exists CHECK (ssn IS NOT NULL),--not specified before, assuming necessary to have a ssn
CONSTRAINT position_ID_range CHECK(job_position_id BETWEEN 1 AND 999), -- make a domain of ID ranges for Job Position
CONSTRAINT company_email CHECK(email LIKE '%@tampaairwaysco.com'),-- make sure they all use their company email 
CONSTRAINT ssn_unique UNIQUE (ssn);-- to create uniqueness in the use of ssn 

--COSTUMERS (6)
ALTER TABLE Customers
ADD CONSTRAINT zipcodeID1_fk1 FOREIGN KEY (zipcode_ID) REFERENCES zipcodes(zipcode_id),  -- Foreign key constraint for referencing zipcodes table
CONSTRAINT cityStateID_fk1 FOREIGN KEY (city_state_ID) REFERENCES cities_states(city_state_id),  -- Foreign key constraint for referencing cities_states table
 CONSTRAINT customer_ID1 UNIQUE (customer_id),  -- Unique constraint for ensuring customer_id values are unique
 CONSTRAINT df_customer1 CHECK (customer_id IS NOT NULL),  -- Check constraint to ensure customer_id is not null
CONSTRAINT fnamecust1Check1 CHECK (datalength(first_name) >= 2),  -- Check constraint for minimum length of first_name
 CONSTRAINT lnamecust1Check1 CHECK (datalength(last_name) >= 2),  -- Check constraint for minimum length of last_name
CONSTRAINT CUSTGENDERCHK1 CHECK (gender = 'M' or gender = 'F'),  -- Check constraint for acceptable gender values (either 'M' or 'F')
CONSTRAINT phone1custCheck1 CHECK (datalength(phone1) > 9),  -- Check constraint for minimum length of phone1
CONSTRAINT phone2custCheck1 CHECK (datalength(phone2) > 9);  -- Check constraint for minimum length of phone2

--TICKETS (6)
ALTER TABLE tickets
ADD CONSTRAINT Not_Negative_Price CHECK (final_price >= 0), -- This will make sure final price is positive.
CONSTRAINT Ticket_Valid CHECK (purchase_date < boarding_date), --This will make sure the purchase date is before the boarding date. 
 CONSTRAINT TicketID_NotNull CHECK (ticket_id IS NOT NULL), --Will make sure the ticket ID has an attribute. 
CONSTRAINT FlightID_NotNull CHECK (flight_id IS NOT NULL), --Will make sure flight id has an attribute. 
CONSTRAINT Limited_Payment_Types CHECK (payment_type_id <= 7), --Will limit the payment type ID to be less than or equal to 7.
CONSTRAINT Valid_Discount_ID CHECK (discount_id >= 1 AND discount_id <= 3); --This will make sure that the discounts IDs are within the range of 1 to 3. 

--LOCATIONS (3)
ALTER TABLE locations -- Altering the 'locations' table
ADD CONSTRAINT CHK_name_length CHECK (DATALENGTH(name) >= 2), -- Adding a check constraint named CHK_name_length to ensure the length of 'name' is at least 2 characters
CONSTRAINT CHK_address_line1_length CHECK (DATALENGTH(address_line1) >= 10), -- Adding a check constraint named CHK_address_line1_length to ensure the length of 'address_line1' is at least 10 characters
CONSTRAINT CHK_address_line2_length CHECK (DATALENGTH(address_line2) >= 10); -- Adding a check constraint named CHK_address_line2_length to ensure the length of 'address_line2' is at least 10 characters



--PLANES(3) 
ALTER TABLE planes
ADD CONSTRAINT Plane_ID_NotNull CHECK (plane_ID IS NOT NULL), -- This will make sure that the plane ID is not null. 
CONSTRAINT Capacity_Range CHECK (capacity BETWEEN 50 and 500), --This will make sure that the capacity of the plane is within a reasonable range. 
CONSTRAINT Model_Length CHECK (DATALENGTH(model) <= 50); -- This will make sure that the length of the model name does not exceed 50 characters.



--Flights Table(3)

ALTER TABLE flights
ADD CONSTRAINT CHK_Flight_Date CHECK (date IS NULL OR date >= '2000-01-01'); --Ensures that the date column is either null or has a value on or after January 1, 2000.

ALTER TABLE flights
ADD CONSTRAINT CHK_Start_Time CHECK (start_time_actual IS NULL OR start_time_actual >= '00:00:00' AND start_time_actual <= '23:59:59'); --Ensures that the start_time_actual column is either null or represents a valid time of day (between 00:00:00 and 23:59:59).

ALTER TABLE flights
ADD CONSTRAINT CHK_End_Time CHECK (end_time_actual IS NULL OR end_time_actual >= '00:00:00' AND end_time_actual <= '23:59:59'); --Ensures that the end_time_actual column is either null or represents a valid time of day (between 00:00:00 and 23:59:59).

--Routes Table(3)

ALTER TABLE routes
ADD CONSTRAINT CHK_Start_Time CHECK (start_time IS NULL OR start_time >= '00:00:00' AND start_time <= '23:59:59'); --Ensures that the start_time column is either null or represents a valid time of day (between 00:00:00 and 23:59:59).

ALTER TABLE routes
ADD CONSTRAINT CHK_End_Time CHECK (end_time IS NULL OR end_time >= '00:00:00' AND end_time <= '23:59:59'); --Ensures that the end_time column is either null or represents a valid time of day (between 00:00:00 and 23:59:59).

ALTER TABLE routes
ADD CONSTRAINT CHK_Weekday_ID CHECK (weekday_id IS NULL OR weekday_id BETWEEN 1 AND 7); --Ensures that the weekday_id column is either null or contains a value between 1 and 7, representing days of the week.

--Discounts Table(3)

ALTER TABLE discounts
ADD CONSTRAINT CHK_Percentage CHECK (percentage IS NULL OR percentage BETWEEN 0 AND 100); --Ensures that the percentage column is either null or contains a value between 0 and 100.

ALTER TABLE discounts
ADD CONSTRAINT CHK_Start_End_Date CHECK (start_date <= end_date OR start_date IS NULL OR end_date IS NULL); --Ensures that the start_date is less than or equal to end_date, or either of them can be null.

ALTER TABLE discounts
ADD CONSTRAINT CHK_Observations_Length CHECK (LEN(observations) <= 100); --Ensures that the length of the observations column does not exceed 100 characters.


